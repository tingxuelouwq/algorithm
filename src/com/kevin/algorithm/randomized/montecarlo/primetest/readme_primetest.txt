    http://blog.codinglabs.org/articles/prime-test.html
    素数检测：给定任意一个大于1的整数，判断这个数是否是素数

    因子检测法：最直观的素数检测算法就是因子检测法，即从2到n^(1/2)一个个判断是否能够整除n，如果有能整除的则说明不是素数，否则认为n是素数。
因子检测法的实现见Main1.java。很明显，因子检测法的时间复杂度为O(n^(1/2))，一般来看，这个时间复杂度已经很不错了，不过对于超级大的数，这个
复杂度还是太大了。

    费马检测：坦白说，对于大素数的检测，目前并没有非常有效的确定性算法，不过借助费马定理，可以构造一种有效的概率算法来进行素数检测。
    费马定理：这条定理是史上最杰出的业余数学家费马发现的一条数论中的重要定理，这条定理可以表述为：
    如果p为素数，则对任何小于p的正整数a有：a^(p-1)≡1(mod p)
    根据基本数理逻辑，一个命题正确，当且仅当其逆否命题正确。所以费马定理蕴含了这样一个事实：如果某个小于p的正整数不符合上述公式，则p一定不
是素数。令人惊讶的是，费马定理的逆命题也“几乎正确”，也就是说，如果所有小于p的正整数都符合上述公式，则p“几乎就是一个素数”。当然，“几乎正确”
就意味着有出错的可能。
    下面通过例子说明一下费马定理表达的意义，例如我们知道7是一个素数，则：
    1^6=1       ≡1(mod 7)
    2^6=64      ≡1(mod 7)
    3^6=729     ≡1(mod 7)
    4^6=4096    ≡1(mod 7)
    5^6=15625   ≡1(mod 7)
    6^6=46656   ≡1(mod 7)
    其他素数可以用类似方法验证。
    因此，可以用如下方法进行大素数探测：选择一个底数(例如2)，对于大整数p，如果2^(p-1)与1不是模p同余数，则p一定不是素数，否则p很可能是一个
素数。
    至于出现假阳性(即合数被判定为素数)的概率，已有研究表明，随着整数趋向于无穷，这个概率趋向于零。在以2为底的情况下，512位整数碰到假阳性的
概率为1/10^20，而在1024位整数中，碰到假阳性的概率为1/10^41，因此如果使用此法检测充分大的数，碰到错误的可能性微乎其微。

    模幂的快速算法：对于大整数p来说，a^(p-1)(mod p)不是一个容易计算的数字，直接计算的效果并不比因子分解好，所以需要寻找一种更有效的取模幂
算法。通常来说，重复平方法是一个不错的选择，下面通过例子介绍一下这个方法。
    假设现在要求2的10次方，一种方法当然是将10个2连乘，不过还有这样一种计算方法：
    10的二进制表示是1010，因此：
    2^10=2^(1010)
    现初始化结果d=2^0=1，我们希望通过乘上某些数，使得d变换到2^10，变换序列如下：
    2^0
    2^0 x 2^0 x 2   = 2^1
    2^1 x 2^1       = 2^10
    2^10 x 2^10 x 2 = 2^101
    2^101 x 2^101   = 2^1010
    可以看到这样一个规律：对中间结果d自身进行平方，等于在二进制指数的尾部生出一个0；对中间结果d自身进行平方再乘以底数，等于在二进制指数尾部
生出一个1。靠这样不断让指数生长，就可以构造出幂。如果在每次运算时取模，就可以得到模幂了。下面是这个算法的Python实现。
   def compute_power(a, p, m):
       result = 1
       p_bin = bin(p)[2:]
       length = len(p_bin)
       for i in range(0, length):
           result = result**2 % m
           if p_bin[i] == '1':
               result = result * a % m

       return result
    这个算法的复杂度正比于a、q和p中位数最多的数的二进制位数，要远远低于朴素的模幂求解法。

    费马检测的实现：有了以上铺垫，下面可以实现费马检测了，见Main2.java，测试结果如下：
    System.out.println(fermatPrimeTest(BigInteger.valueOf(7)));     // true
    System.out.println(fermatPrimeTest(BigInteger.valueOf(11)));    // true
    System.out.println(fermatPrimeTest(BigInteger.valueOf(15)));    // false
    System.out.println(fermatPrimeTest(BigInteger.valueOf(121)));   // false
    System.out.println(fermatPrimeTest(BigInteger.valueOf(561)));   // true
    System.out.println(fermatPrimeTest(new BigInteger("6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151")));   // true
    需要注意的是，倒数第二个结果实际上是错误的，因为561可以分解为3和187。
    相对来说，因子分解法适合比较小的数的探测，可以给出准确的结论，但是对于大整数效率不可接受，例如上面最后一个超大整数，因子分解法基本不
可行；费马测试当给出否定结论时，是准确的，但是肯定结论有可能是错误的，对于大整数的效率很高，并且误判率随着整数的增大而降低。

    Miller-Rabin检测：上文说，费马检测失误的概率随着整数不断增大而趋向于0，看似是对大素数检测很好的算法，但有些合数可以完全欺骗费马检测，
比如561这个数，可以分解为3乘以187，但是如果你试过会发现所有小于561的正整数均符合费马定理公式。这就意味着，费马检测对于561是完全失效的。类
似561这样的合数但是可以完全欺骗费马检测的数叫做Carmichael数。Carmichael数虽然密度不大(前10亿个正整数中约600个)，但是已经被证明有无穷多
个。Carmichael数的存在迫使需要一种更强的检测条件配合单纯费马检测使用，其中Miller-Rabin检测是目前应用比较广泛的一种。
    Miller-Rabin检测依赖以下定理：如果p是素数，x是小于p得正整数，且x^2=1 mod p，则x要么为1，要么为p-1。
    简单证明以上定理：如果x^2=1 mod p，则p整数x^2-1，即整数(x+1)(x-1)，由于p是素数，所以p要么整数x+1，要么整数x-1，前者x为p-1，后者
x为1。
    以上定理说明，如果对于任意一个小于p的正整数x，发现1(模p)的非平凡平方根(即不为1且不为p-1的根)存在，则说明p是合数。
    对于p-1，我们总可以将其表示为u·2^t，其中u是奇数，t是正整数，此时：a^(p-1)=a^(u·2^t)=(a^u)2^t，也就是说我们可以先计算出a^u，然后
经过连续t次平方计算出a^(p-1)，并且在任意一次平方时发现了非平凡平方根，则断定p是合数。
    例如，p=561，则p-1=560=35·2^4，所以可设u=25，t=4，得到：
    2^35 mod 561 = 263
    263^2 mod 561 = 166
    166^2 mod 561 = 67
    67^2 mod 561 = 1
    由于找到了一个非平凡平方根67，所以可以断定561是合数。
    一般的，Miller-Rabin算法的Python实现如下：
    def miller_rabin_witness(a, p):
        if p == 1:
            return False
        if p == 2:
            return True

        n = p - 1
        t = int(floor(log(n, 2)))
        u = 1
        while t > 0:
            u = n / 2**t
            if n % 2**t == 0 and u % 2 == 1:
                break
            t = t - 1

        b1 = b2 = compute_power(a, u, p)
        for i in range(1, t + 1):
            b2 = b1**2 % p
            if b2 == 1 and b1 != 1 and b1 != (p - 1):
                return False
            b1 = b2
        if b1 != 1:
            return False

        return True

    def prime_test_miller_rabin(p, k):
        while k > 0:
            a = randint(1, p - 1)
            if not miller_rabin_witness(a, p):
                return False
            k = k - 1
        return True
    其中miller_rabin_witness用于判断整数p是否为素数，prime_test_miller_rabin共探测k次，每次随机产生一个[1,p-1]之间的正整数，只要
有一次返回false则认为p为合数，否则认为p为素数。
    Miller-Rabin检测同样也存在假阳性问题，但是与费马检测不同，MR检测的正确率不依赖被检测数p(排除了Carmichael数失效问题)，而仅依赖于检
测次数。已经证明，如果一个数p为合数，那么MR误判率为(1/4)^k，其中k是检测次数。
    Miller-Rabin检测的Java实现见Main3.java


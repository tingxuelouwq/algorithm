HashMap的源码中有一个hash函数。
int hash(int h) {
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
为什么要经过这样的运算呢？这就是HashMap的高明之处了。先看个例子，一个十进制数32768(二进制1000 0000 0000 0000)，经过上述公式运算
之后的结果是35080(二进制1000 1001 0000 1000)。看出来了吗？或许这样还看不出什么，再举个数字61440(二进制1111 0000 0000 0000)，
运算结果是65263(二进制1111 1110 1110 1111)，现在应该很明显了，它的目的是让“1”变的均匀一点，散列的本意就是要尽量均匀分布。那这样
有什么意义呢？看第3步。 
得到h之后，把h与HashMap的承载量（HashMap的默认承载量length是16，可以自动变长。在构造HashMap的时候也可以指定一个长度。这个承载量就
是上图所描述的数组的长度。）进行逻辑与运算，即 h & (length-1)，这样得到的结果就是一个比length小的正数，我们把这个值叫做index。其实
这个index就是索引将要插入的值在数组中的位置。第2步那个算法的意义就是希望能够得出均匀的index，这是HashTable的改进，HashTable中的算
法只是把key的hashcode与length相除取余，即hash % length，这样有可能会造成index分布不均匀。还有一点需要说明，HashMap的键可以为null
，它的值是放在数组的第一个位置。 

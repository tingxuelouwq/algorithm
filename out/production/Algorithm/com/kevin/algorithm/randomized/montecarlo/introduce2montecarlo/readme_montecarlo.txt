Monte-Carlo引入：
    首先，我们来看一个有意思的问题：在一个1平方米的正方形木板上，随意画一个圈，求这个圈的面积。
    我们知道，如果圆圈是标准的，则可以通过测量半径r，然后用S=pi*r*r来求出面积。可是，我们画的圆圈一般是不标准的，显然不太可能有面积公式
可以套用，此时我们可以用如下方法求这个图形的面积：
    假设我手里有一支飞镖，我将飞镖掷向木板，并且我们假定每一次都能掷在木板上，但每一次掷在木板的什么地方是完全随机的，也就是说，每一次掷
飞镖，飞镖扎在木板的任何一点的概率都是相等的。这样，我们投掷多次，例如100次，然后统计这100次中扎入不规则图形内部的次数，假设为k，那么我们
就可以用k/100*1近似估计出不规则图形的面积，例如100次中有32次掷入图形内，则我们可以估计出图形面积为0.32平方米。
    以上这个过程就是Monte-Carlo算法的直观应用例子。
    非形式化地说，Monte-Carlo算法泛指一类算法，在这类算法中，要求解的问题是某随机事件发生的概率或某随机变量的期望，这时，可以通过实验，用
频率代替概率，或得到随机变量的某些数字特征，以此作为问题的解。
    上述问题中，如果将”投掷一次飞镖并掷入不规则图形内部“作为事件，则图形的面积在数学上等价于这个事件发生的概率，为了估计这个概率，我们用多
次重复实验的方法，得到事件发生的频率k/100，以此频率估计概率，从而得到问题的解。
    从上述可以看出，Monte-Carlo算法区别于确定性算法，它的解不一定是准确地，其准确性依赖于概率统计，但在某些问题上，当重复实验次数足够大
时，可以从很大概率上确保解的准确性，所以我们可以根据具体的概率分析，设定实验的次数，从而将误差降到一个可容忍的程度。

Monte-Carlo的数理基础：
    首先给出三个定义：优势、一致、偏真。这三个定义在后面会经常用到。
    （1）设p是一个实数，且0.5<p<1。如果一个Monte-Carlo算法对问题任一实例所得到的正确解的概率不小于p，则称该算法是p正确的，且p-0.5叫做
该算法的优势。
    （2）如果对于同一实例，一个Monte-Carlo算法不会给出不同的解，则认为该算法是一致的。
    （3）如果某个解判定问题的Monte-Carlo算法，当返回true时解一定正确的，仅当它返回false时有可能产生错误的解，则这个算法是偏真的。注意，
这里没有定义“偏假“，因为”偏假“和”偏真“是等价的，只要互换算法返回的true和false，“偏假”就变成“偏真”了。

Monte-Carlo算法的可靠性和误差分析：
    总体来说，适用于Monte-Carlo算法的问题，比较常见的有两类。一类是问题的解等价于某事件发生的概率，如上述求不规则图形面积的问题；另一类
问题是判定问题，即判定某个问题是否为真，如主元素存在性判定和素数测试问题。
    先来分析第一类。对于这类问题，通常的方法是通过大量重复性实验，用事件发生的频率估计概率，当试验次数很大时，频率与概率偏差很大的概率非常
小。
    接着，我们分析第二类问题。这里我们只关心一致且偏真的判定问题。下面给出这类问题的正确性分析：
    首先，讨论判定问题本身为false的情况。由于算法是一致且偏真的，所以在这种情况下，任意调用算法MC(x)均返回false，正确率为100%。反证：
由于该算法是一致偏真的，如果此时算法返回true，则说明该判定问题为true，与已知矛盾。
    再讨论判定问题本身为true的情况。设此时一次调用算法MC(x)返回true的概率为p，则返回false的概率为1-p，因为算法一致偏真，所以此时调用算
法n次，得到错误结果的概率为(1-p)^n，得到正确解的概率为1-(1-p)^n，即这种情况的正确率。
    设问题本身的正确率为q，则问题本身为假的概率为1-q，所以，调用n次算法MC(x)的总体正确率为q[1-(1-p)^n]+1-q。
    由以上分析可以看到，对于一致偏真的Monte-Carlo算法，即使调用一次得到正确解的概率非常小，通过多次调用，其正确率会迅速提高，得到的结果
非常可靠。例如，对一个p=0.5的问题，假设p仅为0.01，通过调用1000次，其正确率约为0.9999784，几乎可以认为是绝对正确的。重要的是，使用Monte-
Carlo算法判定问题，其正确率不随问题规模而改变，这就使得仅需要损失微乎其微的正确性，就可以将算法复杂度降低到一个数量级。

Monte-Carlo算法的应用：
    1、计算定积分。为了便于比较，我们使用插值积分法和Monte-Carlo方法计算定积分，通过实验结果数据对两者的效率和精确性进行比较，见Main1.java
    2、在O(n)复杂度内判定主元素。见Main2.java

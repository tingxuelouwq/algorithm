    质数：只能够被1和自己整除
    合数：除能被1和自身整除外，还可以被其他数整数
    1既不是质数，也不是合数
    2是最小的质数
    4是最小的合数

    Pollard's Rho算法是一个非常有趣又容易理解的整数因子分解算法，它并不是目前最快的算法，但它要比试除法快上多个量级。它基于非常简单的思想，
而这种思想同样可以用于其他地方。
    问题提出：我们假设N是一个能被分解成p*q的数(N=p*q且p!=q)，我们的目标是找到N的其中一个因子p或q。
    我们先来看传统的试除法，参见Main1.java。
    接下来我们通过生日悖论来提高概率。这是一个简单而又十分有用的提高概率的技巧，它叫做Birthday Trick。我们举例来说明这个Trick，比如要从
[1,1000]中随机取一个数，取得42的概率为1/1000，事实上，取得任何一个数的概率都为1/1000。我们稍微修改一个这个问题，从[1,1000]中随机选取两
个数i和j，使得i-j=42，此时的概率为958/C(2,1000)≈1/500。可以看到，如果我们不再坚持仅选取1个数并且这个数必须为42，而是选取2个数并且它们
的差值为42，那么成功的概率会被提高。
    如果我们在[1,1000]中选取k个数x1,x2,...,xk，则取得的k个数中满足xi-xj=42的概率是多少呢？这个概率和k有什么关系呢？我们编程来验证，参见
Main2.java。下面的表格展现了不同的k(k>=2)时的情况：
    k=2, prob=0.00174
    k=3, prob=0.00549
    k=4, prob=0.01206
    k=5, prob=0.01926
    k=6, prob=0.0288
    k=10, prob=0.08252
    k=15, prob=0.18254
    k=20, prob=0.30541
    k=25, prob=0.43715
    k=30, prob=0.56507
    k=100, prob=0.99991
    可以看到，大约在k=30时，成功的概率已经超过了一半。也就是说，在区间[1,1000]中，仅仅生成约30个随机数，则其中两个数的差值为42的概率就超过
了一半。
    再看一个例子，我们随机选择k(k>=2)个人，他们的生日相同的概率是多少？我们只需要将前面代码中的42进行修改即可，参见Main3.java。下面的表格
展现了不同的k(k>=2)时的情况。
    k=2, prob=0.002897102897102897
    k=3, prob=0.007852147852147853
    k=4, prob=0.016923076923076923
    k=5, prob=0.026833166833166833
    k=6, prob=0.04075924075924076
    k=10, prob=0.11621378621378621
    k=15, prob=0.25238761238761237
    k=20, prob=0.41063936063936063
    k=25, prob=0.5688211788211788
    k=30, prob=0.707002997002997
    k=60, prob=0.9940359640359641
    k=100, prob=1.0
    可以看到，大约在k=25时，成功的概率已经超过了一半。也就是说，在区间[1,365]中，仅仅生成约25个随机数，则其中两个数相等的概率就超过了一半。
当一个班级有60个人时，由于当k=60时的可能性已经达到0.99，几乎可以肯定地说，这个班级中必定有两个同学的出生日期是相同的，但根据经验，这个概率
似乎是不正确的，这便是悖论。
    让我们回到因子分解问题，现在我们可以提出一个不同的问题，即不再只选取一个整数，而是选取k个整数，并判断xi-xj是否能够整除N(其中，
|xi-xj|!=1，且i!=j)，如果能够整除，则说明xi-xj是N的一个因子。显然，这种做法可以提高成功的概率，参见Main4.java。再进一步，xi-xj只有两种
情况能够整除N，即xi-xj是N的因子，p或者q，但如果我们找使得gcd(xi-xj,N)>1的数的个数，则答案有很多，p、2p、3p、...、(q-1)p、q、2q、3q、
...、(p-1)q，准确地说，我们可以找到p+q-2个数，此时更加提高了成功的概率。所以，一个简单的策略如下：
    1、在区间[1,N]中随机选取k个数，x1,x2,...,xk
    2、判断是否存在gcd(xi-xj,N)>1，若存在，则gcd(xi-xj,N)是N的一个因子(p或q)
    但是以上策略有一个问题，就是我们需要选取大约N^(1/4)个数，当N特别大时，选取的数太多，以至于不能直接存放到内存中。
    为了解决数太多无法存储的问题，出现了Pollard's Rho算法，该算法并不随机生成k个数并两两进行比较，而是一个一个地生成并检查连续的两个数，
反复执行以上步骤以期得到因子。Pollard's Rho算法使用函数f来生成伪随机数，f(x)=(x^2+a) mod N，其中a可以自行指定，也可以随机生成。我们从
x1=2或者其他数开始(可以随机生成[0,n-1]之间的数作为x1)，让x2=f(x1),x3=f(x2),...,x(n+1)=f(xn)。Pollard's Rho算法的伪代码如下：
    x = 2;
    while (true) {
        y = f(x);
        p = gcd(|y - x|, n);
        if (p > 1)
            return p;
        x = y;
    }
    假设N=55，f(x)=(x^2+2) mod 55，则：
    xn      x(n+1)      gcd(|x(n+1)-xn|,N)
    2       6           1
    6       38          1
    38      16          11
    你可以发现，对于大部分的数据这个算法能够正常运行，但是对于某些数据，它将会进入死循环，这是因为存在f环的原因，例如我们可以构造一个伪随机
函数并生成如下的伪随机数：
    2,10,16,23,29,13,16,23,29,13,...
    此时算法就会在16,23,29,13这个圈中无限循环，永远找不到因子。
    我们可以使用Floyd算法来探测f环。假设我们在一个圈中行走，让A每次走一步，让B每次走两步，则A与B相遇时即说明存在f环，相应的伪代码如下：
    a = 2;
    b = 2;
    while (b != a) {
        a = f(a);       // a runs once
        b = f(f(b));    // b runs twice as fast
        p = gcd(|b - a|, n);
        if (p > 1)
            return p;
    }


